### week_0
* Создаю `.github/workflows/go.yaml` - это `ci` процесс, который содержит гитхаб экшены. Их гитхаб будет выполнять на своих серверах(билд в образе нужной ос, запускать линтер, тестить) 
* В makefile создаю цель `lint` для проверки кода 



### week_1 - базовая настройка обоих серваков

#### http
1. `cmd/http_server` - получение данных с тела `http-запроса`, `Decode/Encode`, `request параметры`, `Lock()`
2. `cmd/http_client` - `HTTP POST-запрос`, `HTTP GET-запрос`, `Marshal`

#### grpc
1. В папку `api` помещаю и заполняю декларацию protobuf. Для работы с proto-файлами устанавливаю protoc: `brew install protobuf`
2. После того как декларация готова, из нее можно сгенерировать код на любом языке программирования. Для этого в makefile
   прописываю цели `install-deps` и `generate-note-api`. А чтобы все было еще более автоматизировано, создаю цель `get-deps`
   для загрузки всех необходимых библиотек.
3. `cmd/grpc_server` - имплементирую метод `Get()`



### week_2 - Начало работы с сервером

#### Видео 4.2 - Скомпилированный под линукс бинарник отправляю на сервер по ssh
Нельзя просто скомпилировать код и отправить его на сервер. Полученный бинарник будет собран под систему на которой он был сбилжен.
* Поэтому в makefile добавляю новую цель `build`, которая создает бинарник под необходимую операционку.
* Чтобы подключиться к удаленному серверу, необходимо знать публичный ip: `ssh root@5.159.100.20`
* В makefile создаю цель `copy-to-server`, которая подключиться к серверу и скопирует в него бинарник.

#### Видео 4.3 - Все это необходимо запаковать в докер контейнер
В сравнении с виртуалкой контейнер сильно легче, нет необходимости устанавливать полноценную операционку со своим ядром, потому что можно использовать ядро самого хоста.
Установка Docker на сервак: `https://timeweb.cloud/tutorials/docker/kak-ustanovit-docker-na-ubuntu-22-04`

* Для создания необходимого контейнера реализую `Dockerfile`.
* Создаю на сервере `Container Registry`, в него отправится image. Там же генерирую токен для заполнения команд.
* Чтобы сбилдить dockerfile, прописываю в makefile цель `docker-build-and-push`: билджу image из описанного dockerfile под линукс, логинюсь на удаленный Container Registry и пушу в него образ.
* Подключаюсь к серваку: `ssh root@5.159.100.20`
* Подтягиваю этот образ на сервак : `docker pull cr.selcloud.ru/grpc/test-server:v0.0.1`
* Создаю из образа контейнер: `docker run -p 50051:50051 IMAGE_ID `

#### Видео 4.4 - Автоматизация всего процесса
Для автоматизации всего выше созданного, буду использовать `.github/workflows/week_2_ci.yaml`, а не makefile.
* Цель `image-build-and-push` схожа с `docker-build-and-push` в makefile: билджу images из описанного dockerfile на линуксе, логинюсь на удаленный Container Registry и пушу в него образ.
* А в цели `deploy-image`: подключаюсь к серверу по ssh, останавливаю и удаляю текущий контейнер, подтягиваю образ на сервак, создаю новый контейнер
* Задаю secrets на гитхабе. SSHKEY даю свой приватный ключ, чтобы симулировать работу моего пк на гитхабе.
