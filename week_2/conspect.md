### Видео 4.2 - Скомпилированный под линукс бинарник отправляю на сервер по ssh
Нельзя просто скомпилировать код и отправить его на сервер. Полученный бинарник будет собран под систему на которой он был сбилжен.    
* Поэтому в makefile добавляю новую цель `build`, которая создает бинарник под необходимую операционку.
* Чтобы подключиться к удаленному серверу, необходимо знать публичный ip: `ssh root@5.159.100.20` 
* В makefile создаю цель `copy-to-server`, которая подключиться к серверу и скопирует в него бинарник.

 
### Видео 4.3 - Все это необходимо запаковать в докер контейнер
В сравнении с виртуалкой контейнер сильно легче, нет необходимости устанавливать полноценную операционку со своим ядром, потому что можно использовать ядро самого хоста.
Установка Docker на сервак: `https://timeweb.cloud/tutorials/docker/kak-ustanovit-docker-na-ubuntu-22-04`

* Для создания необходимого контейнера реализую `Dockerfile`.
* Создаю на сервере `Container Registry`, в него отправится image. Там же генерирую токен для заполнения команд.
* Чтобы сбилдить dockerfile, прописываю в makefile цель `docker-build-and-push`: билджу image из описанного dockerfile под линукс, логинюсь на удаленный Container Registry и пушу в него образ.
* Подключаюсь к серваку: `ssh root@5.159.100.20`
* Подтягиваю этот образ на сервак : `docker pull cr.selcloud.ru/grpc/test-server:v0.0.1`
* Создаю из образа контейнер: `docker run -p 50051:50051 IMAGE_ID `


### Видео 4.4 - Автоматизация всего процесса
Для автоматизации всего выше созданного, буду использовать `.github/workflows/week_2_ci.yaml`, а не makefile.
* Цель `image-build-and-push` схожа с `docker-build-and-push` в makefile: билджу images из описанного dockerfile на линуксе, логинюсь на удаленный Container Registry и пушу в него образ.
* А в цели `deploy-image`: подключаюсь к серверу по ssh, останавливаю и удаляю текущий контейнер, подтягиваю образ на сервак, создаю новый контейнер
* Задаю secrets на гитхабе. SSHKEY даю свой приватный ключ, чтобы симулировать работу моего пк на гитхабе. 